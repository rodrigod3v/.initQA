# Evolu√ß√£o do HTTP Request Architect - Documenta√ß√£o T√©cnica

Este documento registra as mudan√ßas arquiteturais e as capacidades funcionais introduzidas no HTTP Request Architect do `.initQA` para competir com ferramentas modernas como Postman e Insomnia por meio de automa√ß√£o avan√ßada.

---

## üöÄ Funcionalidades Principais

### 1. Magic Assert (Auto-Gera√ß√£o)
Reduz o trabalho repetitivo sugerindo testes automaticamente com base no payload e no status da resposta.

- **Asser√ß√µes de Status**: Detecta o status HTTP retornado e cria um teste `pm.response.to.have.status(code)`.
- **Asser√ß√µes de Contrato/Tipo**: Percorre o corpo da resposta JSON e gera asser√ß√µes de verifica√ß√£o de tipo (`to.be.a('string')`, `to.be.an('array')`, etc.).
- **Valida√ß√£o de Propriedades**: Garante que campos espec√≠ficos estejam presentes no objeto de resposta.

### 2. Encadeamento Din√¢mico (Magic Chain)
Facilita o fluxo entre requisi√ß√µes persistindo dados extra√≠dos em vari√°veis de ambiente.

- **Extens√£o do Sandbox**: O objeto `pm` no sandbox de teste foi estendido com `pm.environment.set(key, value)` e `pm.environment.get(key)`.
- **Persist√™ncia no Banco de Dados**: Qualquer vari√°vel definida via `pm.environment.set` √© salva automaticamente no ambiente ativo no banco de dados durante a execu√ß√£o.
- **Detec√ß√£o Inteligente**: A interface identifica campos como `token`, [id](file:///c:/Users/777/.gemini/antigravity/scratch/initQA/backend/src/request/execution/execution.service.ts#91-93) ou `user_id` nas respostas e oferece um bot√£o flutuante de um clique para encade√°-los.

### 3. Motor Multi-Protocolo (GraphQL & gRPC)
Expande as capacidades do arquiteto al√©m das APIs REST padr√£o.

- **Suporte a GraphQL**: Detec√ß√£o autom√°tica do protocolo GraphQL. Ele envolve o corpo bruto em uma estrutura JSON `{query, variables}` e a envia como uma requisi√ß√£o `POST`.
- **Troca de Protocolo**: Um novo seletor de interface permite alternar entre REST, GRAPHQL e GRPC ao n√≠vel da requisi√ß√£o.

---

## üõ†Ô∏è Detalhes da Implementa√ß√£o

### Camada de Banco de Dados (`Prisma`)
- **Atualiza√ß√£o do Modelo**: Adicionado o campo `protocol` ao modelo [Request](file:///c:/Users/777/.gemini/antigravity/scratch/initQA/frontend/src/stores/requestStore.ts#101-108).
- **Valor Padr√£o**: O padr√£o √© `REST` para compatibilidade com vers√µes anteriores.

### L√≥gica do Backend ([ExecutionService](file:///c:/Users/777/.gemini/antigravity/scratch/initQA/backend/src/request/execution/execution.service.ts#7-287))
- **Contexto do Sandbox**: Injetado o objeto `environment` no contexto da `vm`.
- **Persist√™ncia At√¥mica**: O servi√ßo monitora a flag `variablesChanged` durante a execu√ß√£o do script e realiza uma atualiza√ß√£o no Prisma se houver extra√ß√£o.
- **Middleware GraphQL**: L√≥gica adicionada para lidar com a normaliza√ß√£o da query antes da chamada `axios`.

### Interface Frontend (`React`)
- **Seletor de Protocolo**: Integrado na barra de URL para alta visibilidade.
- **Overlays Din√¢micos**: Implementados bot√µes flutuantes posicionados absolutamente sobre o Monaco Editor na aba de resposta para detec√ß√£o de "Magic Chain".
- **Injetor de Script**: L√≥gica para concatenar novos testes ao `testScript` existente sem sobrescrever o c√≥digo escrito pelo usu√°rio.

---

## üìñ Como Usar

### Gerando Testes Automaticamente
1. Execute uma requisi√ß√£o para obter uma resposta.
2. Abra a aba **Functional** no painel de resultados.
3. Clique no bot√£o **`MAGIC_ASSERT`**.
4. O sistema ir√° anexar asser√ß√µes padronizadas ao seu script de teste.

### Encadeando Vari√°veis
1. Execute uma requisi√ß√£o (ex: `POST /auth/login`).
2. Na aba **Response**, procure por um bot√£o flutuante como **`CHAIN_TOKEN`**.
3. Clique nele para adicionar automaticamente a l√≥gica de extra√ß√£o ao seu script de teste.
4. Em requisi√ß√µes subsequentes, use a sintaxe `{{token}}` na URL, Cabe√ßalhos ou Corpo.

### Executando Queries GraphQL
1. Crie uma nova requisi√ß√£o.
2. Alterne o seletor de protocolo de `REST` para `GRAPHQL`.
3. Cole sua query diretamente na aba **Data**.
4. Clique em **EXECUTE**. Nenhuma configura√ß√£o manual de `POST` ou `Content-Type` √© necess√°ria.

---

## üåü Exemplo Real: Fluxo de Autentica√ß√£o

Imagine que voc√™ est√° testando uma API de E-commerce. Veja como usar as novas fun√ß√µes para automatizar o teste:

### Passo 1: Login e Extra√ß√£o de Token
1. Crie uma requisi√ß√£o `POST /login`.
2. Ap√≥s executar, a resposta retorna:
   ```json
   {
     "access_token": "ey123...",
     "user_id": "99"
   }
   ```
3. Clique no bot√£o flutuante **`CHAIN_ACCESS_TOKEN`** que aparecer√° sobre a resposta.
4. O sistema injetar√° automaticamente no seu script:
   ```javascript
   pm.environment.set("access_token", pm.response.json().access_token);
   ```

### Passo 2: Verifica√ß√£o Autom√°tica (Magic Assert)
1. Clique em **`MAGIC_ASSERT`**.
2. O sistema gerar√° testes para garantir que o token √© uma string e que o status √© 200:
   ```javascript
   pm.test("Status code is 200", () => {
       pm.response.to.have.status(200);
   });
   pm.test("access_token has correct type", () => {
       pm.expect(pm.response.json().access_token).to.be.a('string');
   });
   ```

### Passo 3: Uso do Token em Outra Requisi√ß√£o
1. Crie uma requisi√ß√£o `GET /profile`.
2. Nos **Headers**, adicione:
   - `Authorization`: `Bearer {{access_token}}`
3. O sistema substituir√° `{{access_token}}` pelo valor extra√≠do no Passo 1 automaticamente!

---

## üèÜ Caso de Teste Avan√ßado: Fluxo de Pedidos (Multi-Protocolo)

Este exemplo demonstra como a arquitetura permite criar fluxos complexos em minutos:

| Ordem | Requisi√ß√£o | Protocolo | A√ß√£o Cloud-Engine | Resultado |
| :--- | :--- | :--- | :--- | :--- |
| 1 | `POST /login` | **REST** | Clique em `CHAIN_TOKEN` | `{{token}}` salvo no ambiente. |
| 2 | `POST /graphql` | **GRAPHQL** | Envie query de produtos | Clique em `CHANGE_PROD_ID` no 1¬∫ item. |
| 3 | `POST /orders` | **REST** | Use `{{token}}` e `{{prod_id}}` | Clique em `MAGIC_ASSERT` para validar contrato. |

### Exemplo de Script Gerado no Passo 3:
```javascript
// Gerado via Magic Chain no Passo 1 e 2
const token = pm.environment.get("token");
const productId = pm.environment.get("prod_id");

// Gerado via Magic Assert
pm.test("Pedido criado com sucesso", () => {
    pm.response.to.have.status(201);
    pm.expect(pm.response.json()).to.have.property('order_id');
});
```

---

> [!TIP]
> Use o **Magic Assert** primeiro para construir o esqueleto do seu conjunto de testes e, em seguida, refine a l√≥gica de neg√≥cios espec√≠fica manualmente no editor **Functional**.
